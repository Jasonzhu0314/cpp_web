# cpp_web
c++服务器开发

实现一个简单的socket接口编程，服务端向客户端返回网页，使用套接口中常用的函数进行编程开发，提高自己对多线程编程和服务器开发的认识

## 项目目录
```
.
├── bin 
├── include
│   ├── tcp_client.h    客户端类声明
│   └── tcp_server.h    服务端类声明
├── makefile
├── README.md
├── main_client.cc  客户端main函数入口
├── main_server.cc  服务端main函数入口
├── threadpools
│   ├── tcp_client.cc   客户端类定义
│   ├── tcp_server.cc   服务端类定义
│   ├── threadpools.cc  线程池类
│   └── threadpools.h
└── threads
    ├── tcp_client.cc   客户端类定义
    └── tcp_server.cc   服务端类定义

```
## socket 缓冲区工作机制



## 多客户端处理
为了处理多个客户端的连接服务端，使用以下方式进行处理

### I/O阻塞




### 多个子线程
每当有一个新的客户端连接到服务端是，创建一个新的子线程处理客户端的连接，服务端则可以继续等待其他新的客户端连接
```c++
(1) 服务端等待accept，阻塞线程
(2) 客户端连接，服务端创建子线程处理
(3) 服务端回到步骤(1)，继续执行
```
优点：可以同时连接多个客户端

缺点：每当一个客户端请求连接时，就创建一个线程，关闭时，销毁线程，当处于高并发时，频繁的创建和销毁线程，影响效率

```
编译：
make all type=src thread=-lpthread
运行服务端：
./bin/server Port
运行客户端：
./bin/client IP Port
```

### 线程池
为了解决频繁的创建和销毁线程带来的时间消耗
使用线程池创建多个线程，处于wait状态，当有新的任务被放到任务队列时，线程池中的线程被唤醒，处理客户端请求，当处理完成后，线程回到线程池中，处于等待状态
```
(1) 创建一定数量的线程池，并将他们处于等待状态
(2) 客户端发起连接，主线程将任务添加到任务队列，并调用notify，唤醒线程池中的空闲的子线程，处理任务
(3) 主线程等待新的连接，一旦有连接跳转到(2)处理
```

缺点：线程的上下文切换仍然会导致程序的时间消耗

### epoll




## 中断
软中断 cpu
硬中断
硬件发生的中断，任意时间，异步中断


## 用户态到内核态的切换
当用户需要调用内核的代码是，比如说，向屏幕打印输出printf，从缓冲区中读取数据read等函数，实际下面使用的内核封装好的函数，
内核函数
strace命令可以追踪程序的执行状态，包括线程的创建等
```
strace -ff -o log ./bin/server 6001
# -ff 命令有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号
```

## 参考文献
Unix网络编程1 API：可以查看socket的具体的函数的部分


## 需要补充的知识
- [ ] 中断
- [ ] I/O多路复用